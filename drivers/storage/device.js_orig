'use strict';

const { Device } = require('homey');
const modbus = require('jsmodbus');
const net = require('net');
const decodeData = require('../../lib/decodeData.js');
const socket = new net.Socket();




class MennekesModbusStorageDevice extends Device {

    async onInit() {
        let self = this;
        // Register device triggers
        self._changedOperationalStatus = self.homey.flow.getDeviceTriggerCard('changedOperationalStatus');
        self._changedBattery = self.homey.flow.getDeviceTriggerCard('changedBattery');
        self._changedBatteryCharging = self.homey.flow.getDeviceTriggerCard('changedBatteryCharging');
//        self._changedBatteryDischarging = self.homey.flow.getDeviceTriggerCard('changedBatteryDischarging');
        self._changedPowerDrawn = self.homey.flow.getDeviceTriggerCard('changedPowerDrawn');
//        self._changedPowerGridFeedin = self.homey.flow.getDeviceTriggerCard('changedPowerGridFeedin');
        self._changedBatteryCapacity = self.homey.flow.getDeviceTriggerCard('changedBatteryCapacity');
        self._changedCurrent = self.homey.flow.getDeviceTriggerCard('changedCurrent');
//		self._changedCurrentLimit = self.homey.flow.getDeviceTriggerCard('changedCurrentLimit');

        let options = {
            'host': self.getSetting('address'),
            'port': self.getSetting('port'),
            'unitId': 1,
            'timeout': 5000,
            'autoReconnect': true,
            'reconnectTimeout': self.getSetting('polling'),
            'logLabel': 'Mennekes Amtron',
            'logLevel': 'error',
            'logEnabled': false
        }

        let client = new modbus.client.TCP(socket, 3)
        socket.connect(options);

        socket.on('connect', () => {
            self.log('Connected ...');

            self.pollingInterval = self.homey.setInterval(() => {
                Promise.all([
                    client.readHoldingRegisters(104, 1),	/*charger operational code*/
                    client.readHoldingRegisters(716, 2),	/*Battery charged during session in Wh*/
                    client.readHoldingRegisters(1000, 1),	/*current limit*/
                    client.readHoldingRegisters(741, 6),	/*EV ID*/
                    client.readHoldingRegisters(718, 2),	/*Charge duration in seconds*/
					client.readHoldingRegisters(1000, 1),	/*EV_Required energy (Wh)*/
					client.readHoldingRegisters(134, 2),	/*EV_Max_Current (mA)*/
					client.readHoldingRegisters(122, 1),	/*EV_state Control Pilot vehi-cle state in deci-mal format*/
					client.readHoldingRegisters(200, 2) 	/*AC measurements, read complete page*/
                  

                ]).then((results) => {
					
                    let operational_code = 								results[0].response._body._valuesAsArray[0]				;		
					self.log("operational code " + operational_code	);
                    let battery 		 = decodeData.decodeU32(		results[1].response._body._valuesAsArray[0], 0, 0) / 1000.0	;	/*Charged Energy in kWh*/                  
					self.log("Session charged energt " + battery	);
					
                    let current_limit 	 = 								results[2].response._body._valuesAsArray[0]				;	//A
					self.log("current_limit " + current_limit	);
					
                    let EV_ID 			 = decodeData.decodeHexString(	results[3].response._body._valuesAsArray )				;		/*EV ID, to HEX string*/
					self.log("EV_ID: "+EV_ID);
					
					let session_duration = decodeData.decodeU32(		results[4].response._body._valuesAsArray, 0, 0)		/60	;		//minutes
					self.log("Session duration "+ session_duration);
					
					let EV_Required		 = decodeData.decodeU32(		results[5].response._body._valuesAsArray, 0, 0)			;
					self.log("EV_Required energy "+EV_Required);
					
					let EV_curent_max	 = decodeData.decodeU32(		results[6].response._body._valuesAsArray, 0, 0)			;
					self.log("EV_curent_max "+EV_curent_max);
					
					let EV_control_state = 								results[7].response._body._valuesAsArray[0]				;
					self.log("EV_control_state "+EV_control_state);
			
					let power_L1		 = decodeData.decodeU32(		results[8].response._body._valuesAsArray.slice(6,8), 0, 0)	/1000	;
					self.log("power_L1 "+power_L1);
					
					let power_L2		 = decodeData.decodeU32(		results[8].response._body._valuesAsArray.slice(8,10), 0, 0)	/1000		;
					//self.log("power_L2 "+power_L2);
					
					let power_L3		 = decodeData.decodeU32(		results[8].response._body._valuesAsArray.slice(10,12), 0, 0)/1000			;
					//self.log("power_L3 "+power_L3);
					
					let current_L1		 = decodeData.decodeU32(		results[8].response._body._valuesAsArray.slice(12,14), 0, 0) /1000.0	;
					self.log("current_L1 "+current_L1);
					
					let current_L2		 = decodeData.decodeU32(		results[8].response._body._valuesAsArray.slice(14,16), 0, 0) /1000.0	;
					//self.log("current_L2 "+current_L2);
					
					let current_L3		 = decodeData.decodeU32(		results[8].response._body._valuesAsArray.slice(16,18), 0, 0) /1000.0	;
					//self.log("current_L3 "+current_L3);
					
					let tot_energy		 = decodeData.decodeU32(		results[8].response._body._valuesAsArray.slice(18,20), 0, 0)			;
					let tot_power		 = decodeData.decodeU32(		results[8].response._body._valuesAsArray.slice(20,22), 0, 0)			;
					
                    let ac_volt_L1		 = decodeData.decodeU32(		results[8].response._body._valuesAsArray.slice(22,24), 0, 0)			;
					self.log("ac_volt_L1 "+ac_volt_L1);
					
                    let ac_volt_L2		 = decodeData.decodeU32(		results[8].response._body._valuesAsArray.slice(24,26), 0, 0)			;
					let ac_volt_L3		 = decodeData.decodeU32(		results[8].response._body._valuesAsArray.slice(26,28), 0, 0)			;

					let charge 			 = decodeData.decodeU32(		results[2].response._body._valuesAsArray, 0, 0) /1000.0	;		
					
					
					 
					
					let power_drawn 	 = 0;
					let battery_capacity = 0;
					let powergrid_feed_in = 0;
					let discharge = 0;		
					
					
					/*Cant discharge*/
                    //31397, Battery charge, Wh (U64, FIX0)
                    //31401, Battery discharge, Wh (U64, FIX0)

                    // OPERATIONAL STATUS
					let state= "";
					switch(operational_code){						
						case 0 : state = "Available";		break;					
						case 1 : state = "Occupied";		break;
						case 2 : state = "Reserved";		break;													
						case 3 : state = "Unavailable";		break;							
						case 4 : state = "Faulted";			break;														
						case 5 : state = "Preparing";		break;		
						case 6 : state = "Charging";		break;	
						case 7 : state = "Suspended";		break;	
						case 8 : state = "Suspended";		break;								
						case 9 : state = "Finishing";		break;	
						default: state= "Unknown";						
					}	
					
                    if (self.getCapabilityValue('operational_status') != self.homey.__(state) ) {
                        self.setCapabilityValue('operational_status', self.homey.__(state))
                            .then(function () {

                                let tokens = {
                                    status: self.homey.__(state)
                                }
                                self._changedOperationalStatus.trigger(self, tokens, {}).catch(error => { self.error(error) });

                            }).catch(reason => {
                                self.error(reason);
                            });

                    }

                    // BATTERY
                    if (self.getCapabilityValue('battery') != battery) {
                        self.setCapabilityValue('battery', battery)
                            .then(function () {

                                let tokens = {
                                    charge: battery
                                }
                                self._changedBattery.trigger(self, tokens, {}).catch(error => { self.error(error) });

                            }).catch(reason => {
                                self.error(reason);
                            });
                    }

                    // MEASURE_POWER: CHARGE
                    if (self.getCapabilityValue('measure_power.charge') != charge) {
                        self.setCapabilityValue('measure_power.charge', charge)
                            .then(function () {

                                let tokens = {
                                    charging: charge
                                }
                                self._changedBatteryCharging.trigger(self, tokens, {}).catch(error => { self.error(error) });

                            }).catch(reason => {
                                self.error(reason);
                            });
                    }

/*                    // MEASURE_POWER: DISCHARGE
                    if (self.getCapabilityValue('measure_power.discharge') != discharge) {
                        self.setCapabilityValue('measure_power.discharge', discharge)
                            .then(function () {

                                let tokens = {
                                    discharging: discharge
                                }
                                self._changedBatteryDischarging.trigger(self, tokens, {}).catch(error => { self.error(error) });

                            }).catch(reason => {
                                self.error(reason);
                            });
                    }
*/
                    // POWER DRAWN
                    if (self.getCapabilityValue('power_drawn') != tot_power) {
                        self.setCapabilityValue('power_drawn', tot_power)
                            .then(function () {

                                let tokens = {
                                    drawn: tot_power
                                }
                                self._changedPowerDrawn.trigger(self, tokens, {}).catch(error => { self.error(error) });

                            }).catch(reason => {
                                self.error(reason);
                            });
                    }

 /*                   // POWERGRID FEED IN
                    if (self.getCapabilityValue('powergrid_feed_in') != powergrid_feed_in) {
                        self.setCapabilityValue('powergrid_feed_in', powergrid_feed_in)
                            .then(function () {

                                let tokens = {
                                    feedin: powergrid_feed_in
                                }
                                self._changedPowerGridFeedin.trigger(self, tokens, {}).catch(error => { self.error(error) });

                            }).catch(reason => {
                                self.error(reason);
                            });
                    }
*/
                    // BATTERY CAPACITY, Energy required
/*                    if (self.getCapabilityValue('battery_capacity') != EV_Required) {
                        self.setCapabilityValue('battery_capacity', EV_Required)
                            .then(function () {

                                let tokens = {
                                    capacity: EV_Required
                                }
                                self._changedBatteryCapacity.trigger(self, tokens, {}).catch(error => { self.error(error) });

                            }).catch(reason => {
                                self.error(reason);
                            });
                    }
	*/				
					
					 // BATTERY CAPACITY, Energy required
                    if (self.getCapabilityValue('charge_current') != current_L1) {
                        self.setCapabilityValue('charge_current', current_L1)
                            .then(function () {

                                let tokens = {
                                    current: current_L1
                                }
                                self._changedCurrent.trigger(self, tokens, {}).catch(error => { self.error(error) });

                            }).catch(reason => {
                                self.error(reason);
                            });
                    }
					


                }).catch((err) => {
                    self.log(err);
                })
            }, self.getSetting('polling') * 1000);
        });

        socket.on('error', (err) => {
            self.log(err);
            socket.end();
        })

        socket.on('close', () => {
            self.log('Client closed, retrying in 5 seconds');

            self.homey.clearInterval(self.pollingInterval);
            self.homey.setTimeout(() => {
                socket.connect(options);
                self.log('Reconnecting now ...');
            }, 5000)
        })

    }
}

module.exports = MennekesModbusStorageDevice;
